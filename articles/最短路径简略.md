# 最短路径简略

## Dijkstra最短路径算法

用于求单点到各个点的最短路径。

原理：简单来说就是从起点开始，记录各个点距离起点的距离，此时因为其他点并未被遍历到，所以目前只有直连点存在有限距离，其他点均为无限远。开始遍历时选择距离起点最近且并未遍历的点，假如从起点开始经过该点到达其他点可以让距离缩短的话，则更新起点到各个点的距离。当所有点都遍历完后，则最短路径也更新完毕。

```javascript
// 距离矩阵，arr[x][y]值为x到y的距离
var arr = [
    /*          点1       点2       点3       点4        点5       点6    */
    /* 点1 */ [ 0,        1,        12,       Infinity, Infinity, Infinity ],
    /* 点2 */ [ Infinity, 0,        9,        3,        Infinity, Infinity ],
    /* 点3 */ [ Infinity, Infinity, 0,        Infinity, 5,        Infinity ],
    /* 点4 */ [ Infinity, Infinity, 4,        0,        13,       15       ],
    /* 点5 */ [ Infinity, Infinity, Infinity, Infinity, 0,        4        ],
    /* 点6 */ [ Infinity, Infinity, Infinity, Infinity, Infinity, 0        ]
];
var dis = [].concat(arr[0]); // 起点为点1
var book = [true, false, false, false, false, false]; // 记录是否已被遍历

function dijkstra() {
    for (var i = 0; i < 5; i++) {
        // 获取离起点最近且未遍历过的点
        var min = Infinity;
        var minIndex;
        for (var j = 0; j < 6; j++) {
            if (!book[j] && dis[j] < min) {
                min = dis[j];
                minIndex = j;
            }
        }
        book[minIndex] = true; // 标记为已遍历

        // 比较目前已知的最短距离和假如从当前点经过时的最短距离
        for (var p = 0; p < 6; p++) {
            if(arr[minIndex][p] < Infinity && dis[minIndex] + arr[minIndex][p] < dis[p]) {
                // 当经由第三方点可以得到更短距离的时候，更新最短距离
                dis[p] = dis[minIndex] + arr[minIndex][p];
            }
        }
    }

    console.log(dis);
};

dijkstra();
```

## Floyd最短路径算法

用于求任意两点间的最短距离

原理：基于动态规划都算法，逐点遍历，假如存在经由其他点可以缩短两点间的距离，则更新两点的距离。

```javascript
// 距离矩阵，arr[x][y]值为x到y的距离
var arr = [
    /*          点1       点2       点3       点4      */
    /* 点1 */ [ 0,        2,        6,        4        ],
    /* 点2 */ [ Infinity, 0,        3,        Infinity ],
    /* 点3 */ [ 7,        Infinity, 0,        1        ],
    /* 点4 */ [ 5,        Infinity, 12,       0        ]
];

function floyd() {
    for(var i=0; i<4; i++) {
        for(var j=0; j<4; j++) {
            for(var p=0; p<4; p++) {
                if(arr[j][i] + arr[i][p] < arr[j][p]) {
                    arr[j][p] = arr[j][i] + arr[i][p];
                }
            }
        }
    }

    console.log(arr);
}

floyd();
```
