</DOCTYPE html>
<html>
<head>
    <title>javascript基础</title>
    <style type="text/css">
        html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td {
    margin: 0;
    padding: 0;
    border: 0;
    outline: 0;
    font-weight: inherit;
    font-style: inherit;
    font-family: inherit;
    font-size: 100%;
    vertical-align: baseline;
}

body {
    line-height: 1;

    font-family: "microsoft yahei",Arial,Helvetica,sans-serif;
    font-size: 100%;
    background: #fff;
    color: #817c7c;
    line-height: 1.5;
}

* {
    -webkit-margin-before: 0;
    -webkit-margin-after: 0;
}

.container {
    width: 1000px;
    margin: 0 auto;
    overflow: hidden;
    line-height: 1.8;
    font-size: 14px;
}

.article-content {
    padding: 1.5em 4% 5em;
    color: #413f3f;
    font-size: 100%;
}

caption,th,td {
    text-align: left;
    font-weight: normal;
    vertical-align: middle;
}

a img {
    border: none;
}

small {
    font-size: 80%;
}

sub,sup {
    font-size: 75%;
    line-height: 0;
    position: relative;
    vertical-align: baseline;
}

sup {
    top: -.5em;
    padding-left: .3em;
}

sub {
    bottom: -.25em;
}

a {
    text-decoration: none;
    color: #2ca6cb;
}

a:hover {
    color: #d14;
}

h1 {
    font-size: 200%;
    line-height: 1.5em;
    padding-bottom: .3em;
    border-bottom: 2px solid #dbdbdb;
}

h2 {
    margin-top: 2.6em;
    padding-left: 20px;
    font-size: 160%;
    line-height: 1.2em;
    border-left: 4px solid #2ca6cb;
}

h2:first-child {
  margin-top: 1.5em;
}

h3 {
    font-size: 140%;
    line-height: 1em;
    margin-top: 1.3em;
}

h1, h2 {
    position: relative;
    margin-top: 1.5em;
    margin-bottom: 1em;
}

h4 {
  font-weight: bold;
  font-size: 110%;
}

h4, h5, h6 {
    margin-top: .8em;
    font-size: 130%;
}

h1, h2, h3, h4, h5, h6 {
    color: #333;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
}

h1 >code, h2 >code, h3 >code, h4 >code, h5 >code, h6 >code {
    color: #a3a3a3;
}

hr {
    border: 1px solid #dbdbdb;
}

strong {
    font-weight: bold;
}

em {
    font-style: italic;
}

acronym, abbr {
    border-bottom: 1px dotted;
}

blockquote {
    border-left: .2em solid #aaa;
    margin: 1em;
    padding: .7em;
    line-height: 1.5;
    font-size: 100%;
    color: #808080;
    background-color: #f8f8f8;
}

blockquote footer {
    background: #fafafa;
    padding: 0;
    margin: 0;
    font-size: 80%;
    line-height: 1em;
}

blockquote cite {
    font-style: italic;
    padding-left: .5em;
}

blockquote p {
    margin: 0;
}

ul, ol {
    list-style: none;
    padding-left: 3em;
    font-size: 105%;
    padding-top: .7em;
}

ul li {
    list-style: disc;
    text-align: match-parent;
}

ol li {
    list-style-type: decimal;
}

dl dt {
    font-weight: blod;
}

ul li>code, ol li>code, p code, strong code, em code, table th>code, table td>code {
    font-family: Monaco,Menlo,Consolas,Courier New,monospace;
    background: #eee;
    color: #d14;
    border: 1px solid #d6d6d6;
    padding: 0 5px;
    margin: 0 2px;
    font-size: 90%;
    white-space: nowrap;
    text-shadow: 0 1px #fff;
    -webkit-border-radius: .25em;
    -webkit-border-radius: .25em;
    border-radius: .25em;
}

p {
    line-height: 1.5;
    margin-top: .7em;
    font-size: 110%;
    letter-spacing: 1px;
}

p.image-wrapper {
    text-align: left;
}

img, video, figure img {
    margin: 10px 0;
    max-width: 100%;
    height: auto;
    vertical-align: middle;
    margin-top: .5em;

    border-radius: 5px;
    box-shadow: 2px 2px 7px 1px #aaa;
}

table {    
    vertical-align: middle;
    max-width: 100%;
    border-collapse: collapse;
    border-spacing: 0;
    margin-top: 1em;
    border: 2px solid #cbcbcb;
    color: #413f3f;
}

table tbody tr:nth-child(odd) {
    background-color: #f8f8f8;
}

table th {
    font-weight: bold;
    border: 1px solid #cbcbcb;
    border-bottom: 2px solid #cbcbcb;
    padding: .8em;
    line-height: 1.3em;
}

table td {
    border: 1px solid #cbcbcb;
    padding: .8em;
    line-height: 1.3em;
}

pre {
    background: #2d2d2d;
    margin: .5em 0;
    padding: .5em 2%;
    color: #ccc;
    line-height: 1.5;
    font-size: .8em;
    -webkit-border-radius: .35em;
    -webkit-border-radius: .35em;
    border-radius: .35em;
    word-wrap: break-word;
    font-family: Monaco,Menlo,Consolas,Courier New,monospace;
    overflow-x: auto;
}


pre::-webkit-scrollbar, pre::-webkit-scrollbar-track {
    height: 8px;
    background-color: transparent;
}
pre::-webkit-scrollbar-thumb {
    height: 8px;
    background-color: #ddd;
    border-radius: 4px;
}


.hljs {
  display: block;
  overflow-x: auto;
  padding: 0.5em;
  color: #abb2bf;
  background: #282c34;
}

.hljs-comment,
.hljs-quote {
  color: #5c6370;
  font-style: italic;
}

.hljs-doctag,
.hljs-keyword,
.hljs-formula {
  color: #c678dd;
}

.hljs-section,
.hljs-name,
.hljs-selector-tag,
.hljs-deletion,
.hljs-subst {
  color: #e06c75;
}

.hljs-literal {
  color: #56b6c2;
}

.hljs-string,
.hljs-regexp,
.hljs-addition,
.hljs-attribute,
.hljs-meta-string {
  color: #98c379;
}

.hljs-built_in,
.hljs-class .hljs-title {
  color: #e6c07b;
}

.hljs-attr,
.hljs-variable,
.hljs-template-variable,
.hljs-type,
.hljs-selector-class,
.hljs-selector-attr,
.hljs-selector-pseudo,
.hljs-number {
  color: #d19a66;
}

.hljs-symbol,
.hljs-bullet,
.hljs-link,
.hljs-meta,
.hljs-selector-id,
.hljs-title {
  color: #61aeee;
}

.hljs-emphasis {
  font-style: italic;
}

.hljs-strong {
  font-weight: bold;
}

.hljs-link {
  text-decoration: underline;
}


    </style>
</head>
<body>
<div class="container">
    <div class="article-content">
        <h1 id="javascript-">javascript基础</h1>
<h2 id="-">特性</h2>
<ul>
<li>动态</li>
<li>弱类型</li>
</ul>
<h2 id="-">类型</h2>
<h3 id="-">基础类型</h3>
<p>原本有六种：Undefined/Null/Boolean/String/Number/Object
ES6追加了一种：Symbol（表示是唯一数据的一种类型）</p>
<h3 id="typeof">typeof</h3>
<p>可能的返回值：undefined/boolean/string/number/object/function
其中对null和array使用typeof都会返回object，而ES6中对Symbol使用typeof返回symbol</p>
<h3 id="-">类型转换</h3>
<ul>
<li>字符串转数字：<code>parseInt</code>/<code>parseFloat</code></li>
<li>其它类型转字符串：<code>xxx.toString()</code>/<code>&#39;&#39;+sth</code></li>
<li>其他类型转布尔值：<code>!!sth</code></li>
<li>其他类型转整型数字：<code>~~sth</code></li>
</ul>
<h3 id="-">相等比较</h3>
<ul>
<li>==：相等比较，只比较值，假如类型不同会进行类型转换后再比较</li>
<li>===：全等比较，同时比较类型和值</li>
</ul>
<h2 id="-">语句</h2>
<h3 id="-">常见语句</h3>
<p>if/switch/for/for-in/while/do-while/continue/break…</p>
<h3 id="-">声明语句</h3>
<p>var/function（声明会提前，其中function声明优先于var声明）</p>
<h3 id="-">语句块</h3>
<p>js中本身无块级作用域，在ES6中加入let和const，可产生块级作用域</p>
<h3 id="-">逻辑表达式</h3>
<p>相与相或会出现短路情况：假如是相与，遇到值为假即返回，假如是相或，遇到值为真即返回。</p>
<h3 id="-">关键字运算符</h3>
<ul>
<li>delete：删除某个对象的某个属性</li>
<li>typeof：判断变量的类型</li>
<li>void：计算表达式，返回undefined。如<code>void 0</code>或<code>void(0)</code></li>
<li>instanceof：判断变量是否属于某个类的实例</li>
</ul>
<h3 id="-">运算符优先级</h3>
<ul>
<li><code>.</code>、<code>[]</code>和<code>()</code></li>
<li>自增、自减、delete、new、typeof、void等</li>
<li>乘除取模</li>
<li>加减</li>
<li>其他等</li>
</ul>
<h2 id="-">函数</h2>
<h3 id="-">函数声明/函数表达式/命名函数表达式</h3>
<ul>
<li>函数声明：<code>function func() {}</code></li>
<li>函数表达式：<code>var f = function() {}</code></li>
<li>命名函数表达式：<code>var f = function func() {}</code></li>
</ul>
<h3 id="this">this</h3>
<p>this表示当前上下文，即当前函数的调用者，可以使用bind/call/apply进行修改</p>
<p>1、在函数调用中（处于全局中的函数），this指向全局环境。
2、处于对象中的函数调用中，this指向该对象（即调用的那一级）。
3、当对象被实现后，即用new创建后，this则指向该对象。</p>
<h3 id="arguments">arguments</h3>
<p>伪数组，存储当前执行函数的信息，包括函数名，当前函数的引用和参数等。使用<code>[].slice.call(arguments)</code>可转成数组。</p>
<ul>
<li>arguments.name: 当前函数名</li>
<li>arguments.callee：当前函数的引用</li>
</ul>
<h3 id="-">函数调用者</h3>
<pre><code class="lang-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">a</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log(a.caller); <span class="hljs-comment">// 输出当前函数的调用函数的引用，没有时则为null</span>
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">b</span>(<span class="hljs-params"></span>) </span>{
  a(); <span class="hljs-comment">// 输出b函数</span>
}
</code></pre>
<h3 id="-">原型/原型链</h3>
<p>每个构造函数都有<code>prototype</code>属性，该属性存的是一个实例，该实例的constructor为自身。每个实例都有一个<code>__proto__</code>属性，该属性指向构造函数的<code>prototype</code>。当寻找实例的属性时，从该实例的<code>__proto__</code>往上找，若找不到就找<code>__proto__</code>的<code>__proto__</code>。这个寻找方式其实就是沿着原型链查找属性。</p>
<p>使用delete关键字可以删除一个对象的属性。
hasOwnProperty可以判断是否是自有属性，防止被重写。</p>
<h3 id="-">原型继承/类继承</h3>
<p>原型继承：根据原型实现的继承
类继承：Object.create中提供的继承方式，在es6中还提供了class和extend的方式来继承</p>
<h3 id="-">作用域/作用域链</h3>
<p>作用域是变量与函数的可访问范围。在js中，变量的作用域有全局作用域和局部作用域两种。</p>
<h4 id="-global-scope-">全局作用域（Global Scope）</h4>
<p>在代码中任何地方都能访问到的对象拥有全局作用域，一般来说以下几种情形拥有全局作用域：</p>
<p>最外层函数和在最外层函数外面定义的变量拥有全局作用域，所有末定义直接赋值的变量自动声明为拥有全局作用域，例如：</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">0</span>;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>{
    b = <span class="hljs-number">1</span>;
    alert(a); <span class="hljs-comment">// 0</span>
    alert(<span class="hljs-number">1</span>); <span class="hljs-comment">// 1</span>
}
alert(a); <span class="hljs-comment">// 0</span>
alert(<span class="hljs-number">1</span>); <span class="hljs-comment">// 1</span>
</code></pre>
<p>全局作用域实际上就是window作用域，在全局作用域下的变量都是挂在window对象下。</p>
<h4 id="-local-scope-">局部作用域（Local Scope）　　</h4>
<p>和全局作用域相反，局部作用域一般只在固定的代码片段内可访问到，最常见的是在函数内部，例如下列代码中的b只拥有局部作用域。</p>
<pre><code class="lang-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">var</span> b = <span class="hljs-number">0</span>;
}
alert(b); <span class="hljs-comment">// error</span>
</code></pre>
<h4 id="-scope-chain-">作用域链（Scope Chain）</h4>
<p>在JavaScript中，函数也是对象，实际上，JavaScript里一切都是对象。函数对象和其它对象一样，拥有可以通过代码访问的属性和一系列仅供JavaScript引擎访问的内部属性。其中一个内部属性是[[Scope]]，由ECMA-262标准第三版定义，该内部属性包含了函数被创建的作用域中对象的集合，这个集合被称为函数的作用域链，它决定了哪些数据能被函数访问。</p>
<p>当一个函数创建后，它的作用域链会被创建此函数的作用域中可访问的数据对象填充。例如定义下面这样一个函数：</p>
<pre><code class="lang-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span><span class="hljs-params">(num1, num2)</span> {</span>
    var <span class="hljs-built_in">sum</span> = num1 + num2;
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span>;
}
</code></pre>
<p>在函数add创建时，它的作用域链中会填入一个全局对象，该全局对象包含了所有全局变量。函数add的作用域将会在执行时用到。例如执行如下代码：</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> total = <span class="hljs-keyword">add</span>(<span class="hljs-number">5</span>, <span class="hljs-number">10</span>);
</code></pre>
<p>执行此函数时会创建一个称为“运行期上下文”的内部对象，运行期上下文定义了函数执行时的环境。每个运行期上下文都有自己的作用域链，用于标识符解析，当运行期上下文被创建时，而它的作用域链初始化为当前运行函数的[[Scope]]所包含的对象。</p>
<p>这些值按照它们出现在函数中的顺序被复制到运行期上下文的作用域链中。它们共同组成了一个新的对象，叫“活动对象”，该对象包含了函数的所有局部变量、命名参数、参数集合以及this，然后此对象会被推入作用域链的前端，当运行期上下文被销毁，活动对象也随之销毁。</p>
<p>在函数执行过程中，每遇到一个变量，都会经历一次标识符解析过程以决定从哪里获取和存储数据。该过程从作用域链头部，也就是从活动对象开始搜索，查找同名的标识符，如果找到了就使用这个标识符对应的变量，如果没找到继续搜索作用域链中的下一个对象，如果搜索完所有对象都未找到，则认为该标识符未定义。函数执行过程中，每个标识符都要经历这样的搜索过程。
作用域链和代码优化</p>
<p>从作用域链的结构可以看出，在运行期上下文的作用域链中，标识符所在的位置越深，读写速度就会越慢。因为全局变量总是存在于运行期上下文作用域链的最末端，因此在标识符解析的时候，查找全局变量是最慢的。所以，在编写代码的时候应尽量少使用全局变量，尽可能使用局部变量。一个好的经验法则是：如果一个跨作用域的对象被引用了一次以上，则先把它存储到局部变量里再使用。例如下面的代码：</p>
<pre><code class="lang-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">changeColor</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'btnChange'</span>).onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'targetCanvas'</span>).style.backgroundColor = <span class="hljs-string">'red'</span>;
    };
}
</code></pre>
<p>　　
这个函数引用了两次全局变量document，查找该变量必须遍历整个作用域链，直到最后在全局对象中才能找到。这段代码可以重写如下：</p>
<pre><code class="lang-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">changeColor</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> doc = <span class="hljs-built_in">document</span>;
    doc.getElementById(<span class="hljs-string">'btnChange'</span>).onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        doc.getElementById(<span class="hljs-string">'targetCanvas'</span>).style.backgroundColor = <span class="hljs-string">'red'</span>;
    };
}
</code></pre>
<p>这段代码比较简单，重写后不会显示出巨大的性能提升，但是如果程序中有大量的全局变量被从反复访问，那么重写后的代码性能会有显著改善。</p>
<h3 id="-">闭包</h3>
<p>返回值为函数（相当于函数嵌套函数），主要用于保存数据的引用和保护作用域。</p>
<h3 id="-">特殊语句及函数的性能影响</h3>
<ul>
<li>with：with在作用域链上增加了一个新作用域，而原本的作用域处于作用域链中第二个位置</li>
<li>catch：同with语句，会增加新作用域</li>
<li>eval：会创造新的执行环境</li>
<li>使用尾调用或尾递归可以在当前作用域出栈后再进入新的作用域，对代码执行进行优化</li>
</ul>
<h2 id="dom">DOM</h2>
<h3 id="-">节点类型判断</h3>
<p>通过nodeType来判断，1为元素节点，2为属性节点，3为文本节点，8为注释节点，9为文档节点（即document）</p>
<h3 id="-">节点操作</h3>
<ul>
<li>增加：createElement/createAttribute/createTextNode</li>
<li>删除：removeChild</li>
<li>查找：getElementById/getElementsByTag/getElementsByName/querySelector/quertSelectorAll/firstChild/lastChild/parentNode/nextSibling/previousSibling/childNodes</li>
<li>更新：innerHTML/innerText/insertAdjacentHTML/insertBefore/appendChild</li>
<li>复制：cloneNode（传入true表示要拷贝子节点，不传表示只拷贝当前节点）</li>
<li>替换：replaceChild</li>
</ul>
<h3 id="-">节点属性操作</h3>
<h4 id="attribute">attribute</h4>
<p>attribute由HTML来定义，并不存在于DOM中，即：只要是HTML标签内定义的都是attribute，attribute只能是String类型。</p>
<ul>
<li>增加：setAttribute</li>
<li>删除：removeAttribute</li>
<li>查找：getAttribute</li>
</ul>
<h4 id="property">property</h4>
<p>property属于DOM，DOM的本质就是JS中的一个object。我们可以像操作普通Object一样读取、设置property，property可以是任意类型。通常通过<code>elem.xxx</code>来修改或获取property。</p>
<p>PS：非自定义attribute，如id、class、titile等，都会有对应的property映射，并且变化是联动的。但是自定义的attribute和property则互不相干（IE6-7除外）。
PS：另外带有默认值的attribute不会随property变化而变化，如<code>&lt;input value=&quot;foo&quot;&gt;</code>中的value属性。</p>
<h3 id="dom-">DOM树遍历</h3>
<ul>
<li>previous[next]Sibling：返回上一个/下一个节点，包含文本节点、注释节点。</li>
<li>previous[next]ElementSibling：返回上一个/下一个元素</li>
<li>TreeWalker：高版本浏览器提供的一个用于遍历DOM树的对象，可以对节点进行遍历和过滤</li>
</ul>
<h2 id="-">事件</h2>
<h3 id="-">事件模型</h3>
<p>三个阶段，捕获，目标，冒泡</p>
<h3 id="-">事件类型</h3>
<h4 id="-">鼠标事件</h4>
<pre><code>onclick     <span class="hljs-string">| 鼠标单击时触发</span>
ondbclick   <span class="hljs-string">| 鼠标双击时触发</span>
onmousedown <span class="hljs-string">| 鼠标左键按下时触发</span>
onmouseup   <span class="hljs-string">| 鼠标释放时触发</span>
onmouseover <span class="hljs-string">| 鼠标的光标移动到某对象上时触发</span>
onmousemove <span class="hljs-string">| 鼠标移动时触发</span>
onmouseout  <span class="hljs-string">| 鼠标光标离开某对象时触发</span>
</code></pre><p>ps:当单击一次鼠标左键的时候，将同时触发onclick、onmousedown、onmouseup三个事件，事件处理程序执行的先后顺序为：onmousedown &gt; onmouseup &gt; onclick。</p>
<h4 id="-">键盘事件</h4>
<pre><code>onkeypress <span class="hljs-string">| 某个键按下以后触发</span>
onkeydown  <span class="hljs-string">| 某个键按下时触发</span>
onkeyup    <span class="hljs-string">| 某个键被释放时触发</span>
</code></pre><p>ps:对键盘的操作也会同时触发这三个事件，其处理程序执行的先后顺序是onkeydown &gt; onkeypress &gt; onkeyup。
ps:键盘事件中通过which（旧ff使用）/keyCode/charCode获取键值</p>
<h4 id="-">页面事件</h4>
<pre><code>onerror  <span class="hljs-string">| 页面出错时触发</span>
onload   <span class="hljs-string">| 页面加载完成时触发</span>
onresize <span class="hljs-string">| 浏览器窗口大小该表时触发</span>
onscroll <span class="hljs-string">| 浏览器滚动条的位置发生变化时触发</span>
onunload <span class="hljs-string">| 页面将被卸载时触发</span>
</code></pre><h4 id="-">表单事件</h4>
<pre><code>onblur   <span class="hljs-string">| 元素失去焦点时触发</span>
onchange <span class="hljs-string">| 元素失去焦点并且元素内容改变时触发</span>
onfocus  <span class="hljs-string">| 元素获得焦点时触发</span>
onsubmit <span class="hljs-string">| 表单被提交时触发</span>
</code></pre><h3 id="-">事件调度（事件循环）</h3>
<h3 id="-">事件监听</h3>
<pre><code class="lang-javascript"><span class="hljs-comment">/* 添加事件监听 */</span>
<span class="hljs-keyword">var</span> eventName = <span class="hljs-string">'click'</span>;
<span class="hljs-keyword">var</span> callback = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{};

<span class="hljs-keyword">if</span>(<span class="hljs-built_in">window</span>.addEventListener) {
    <span class="hljs-built_in">window</span>.addEventListener(eventName, callback);
} <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">// IE8以下</span>
    <span class="hljs-built_in">window</span>.attachEvent(<span class="hljs-string">'on'</span> + eventName, callback);
}

<span class="hljs-comment">/* 删除事件监听 */</span>
<span class="hljs-keyword">if</span>(<span class="hljs-built_in">window</span>.removeEventListener) {
    <span class="hljs-built_in">window</span>.removeEventListener(eventName, callback);
} <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">// IE8以下</span>
    <span class="hljs-built_in">window</span>.detachEvent(<span class="hljs-string">'on'</span> + eventName, callback);
}
</code></pre>
<p>其中标准的addEventListener是允许第三个参数userCapture，表示事件进行的阶段，true为捕获阶段，false为冒泡阶段，默认为false。</p>
<h3 id="-">监听回调事件对象信息</h3>
<p>在监听事件的回调中，通常我们使用以下方式，目的是为了兼容IE和FF：</p>
<pre><code class="lang-javascript">function(<span class="hljs-keyword">event</span>) {
  <span class="hljs-comment">// IE8以下只能通过window.event获取，旧版本ff只能通过传入的event获取</span>
    <span class="hljs-keyword">event</span> = <span class="hljs-keyword">event</span> || <span class="hljs-keyword">window</span>.<span class="hljs-keyword">event</span>;
}
</code></pre>
<h3 id="-">取消默认事件</h3>
<pre><code class="lang-javascript"><span class="hljs-keyword">if</span>(<span class="hljs-keyword">event</span>.preventDefault) {
    <span class="hljs-keyword">event</span>.preventDefault();
} <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">// ff</span>
    <span class="hljs-keyword">event</span>.returnValue = <span class="hljs-literal">false</span>;
}
</code></pre>
<h3 id="-">阻止事件冒泡</h3>
<pre><code class="lang-javascript"><span class="hljs-keyword">if</span>(<span class="hljs-keyword">event</span>.stopPropagation) {
    <span class="hljs-keyword">event</span>.stopPropagation();
} <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">// IE8以下</span>
    <span class="hljs-keyword">event</span>.cancelBubble = <span class="hljs-literal">true</span>;
}
</code></pre>
<h3 id="-">可信任事件</h3>
<p>如果一个事件是由设备本身（如浏览器）触发的，而不是通过JavaScript模拟合成的，那个这个事件被称为可信任的，通过<code>event.isTrusted</code>可以得知。</p>
<h3 id="-">自定义事件</h3>
<p>先存储事件句柄，待触发事件时遍历事件句柄并逐个调用。</p>
<pre><code class="lang-javascript"><span class="hljs-comment">// 创建事件</span>
<span class="hljs-keyword">var</span> evt = <span class="hljs-keyword">new</span> Event(<span class="hljs-string">'xxx'</span>);
<span class="hljs-comment">// 创建携带更多信息的事件</span>
<span class="hljs-keyword">var</span> evt = <span class="hljs-keyword">new</span> CustomEvent(<span class="hljs-string">'xxx'</span>, {<span class="hljs-string">'aa'</span>: <span class="hljs-number">1</span>});
<span class="hljs-comment">// 过时的创建事件方法</span>
<span class="hljs-keyword">var</span> evt = <span class="hljs-built_in">document</span>.createEvent(<span class="hljs-string">'Event'</span>);
evt.initEvent(<span class="hljs-string">'xxx'</span>, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">true</span>);
<span class="hljs-comment">// IE8以下创建事件</span>
<span class="hljs-keyword">var</span> evt = <span class="hljs-built_in">document</span>.createEventObject();

<span class="hljs-comment">// 触发事件</span>
elem.dispatchEvent(evt);
<span class="hljs-comment">// IE8以下触发事件</span>
elem.fireEvent(<span class="hljs-string">'onxxx'</span>, evt);

<span class="hljs-comment">// 事件监听，和其他事件监听方式一样</span>
</code></pre>
<h2 id="-">样式</h2>
<h3 id="-">样式表操作</h3>
<p>方法有六种：</p>
<pre><code class="lang-javascript"><span class="hljs-comment">/* 第一种 */</span>
element.className = <span class="hljs-string">'xxx'</span>;

<span class="hljs-comment">/* 第二种 */</span>
element.style.cssText = <span class="hljs-string">'xxx:xxx;xxx:xxx;'</span>;

<span class="hljs-comment">/* 第三种 */</span>
element.style[<span class="hljs-string">'cssAttrName'</span>] = <span class="hljs-string">'xxx'</span>;

<span class="hljs-comment">/* 第四种 */</span>
<span class="hljs-comment">// 高版本浏览器</span>
<span class="hljs-built_in">window</span>.getComputedStyle(<span class="hljs-string">'元素'</span>, <span class="hljs-string">'伪类'</span>); <span class="hljs-comment">// 只读，获取元素的所有样式的数组，包括未在样式表里定义的样式亦能返回值</span>
<span class="hljs-built_in">document</span>.defaultView.getComputedStyle(<span class="hljs-string">'元素'</span>, <span class="hljs-string">'伪类'</span>); <span class="hljs-comment">// 同上</span>
<span class="hljs-built_in">window</span>.getComputedStyle(<span class="hljs-string">'元素'</span>, <span class="hljs-string">'伪类'</span>).getPropertyValue(<span class="hljs-string">'样式名'</span>); <span class="hljs-comment">// 只读，获取元素的单一样式</span>
<span class="hljs-comment">// 低版本IE</span>
element.currentStyle; <span class="hljs-comment">// 同getComputedStyle接口</span>
element.currentStyle.getAttribute(<span class="hljs-string">'样式名'</span>); <span class="hljs-comment">// 同getPropertyValue接口，唯一不同的是传入的样式名需要用驼峰形式，如font-size需传入fontSize</span>

<span class="hljs-comment">/* 第五种 */</span>
<span class="hljs-comment">// 高版本浏览器和IE10以上才支持</span>
element.classList.add(<span class="hljs-string">'xxx'</span>); <span class="hljs-comment">// 添加一个class</span>
element.classList.remove(<span class="hljs-string">'xxx'</span>); <span class="hljs-comment">// 删除一个class</span>
element.classList.toggle(<span class="hljs-string">'xxx'</span>); <span class="hljs-comment">// 切换一个class，有则删除并返回false，无则添加并返回true</span>

<span class="hljs-comment">/* 第六种 */</span>
<span class="hljs-comment">// 此方法属于直接修改页面中的样式</span>
<span class="hljs-keyword">var</span> sheet = <span class="hljs-built_in">document</span>.styleSheets[<span class="hljs-number">0</span>];
<span class="hljs-keyword">if</span>(sheet) {
    <span class="hljs-keyword">var</span> selector = <span class="hljs-string">'.box'</span>;
    <span class="hljs-keyword">var</span> rule = <span class="hljs-string">'background: red;'</span>
    <span class="hljs-keyword">var</span> index = <span class="hljs-number">0</span>; <span class="hljs-comment">// 插入位置</span>
    <span class="hljs-keyword">if</span>(sheet.insertRule) {
        sheet.insertRule(selector + <span class="hljs-string">'{'</span> + rules + <span class="hljs-string">'}'</span>, index);
    } <span class="hljs-keyword">else</span> {
        sheet.addRule(selector, rules, index);
    }
    <span class="hljs-comment">// 删除样式</span>
    sheet.deleteRule(index);
    <span class="hljs-comment">// 遍历样式</span>
    <span class="hljs-keyword">var</span> cssRules = <span class="hljs-built_in">Array</span>.prototype.slice.call(sheet.cssRules, <span class="hljs-number">0</span>);
    cssRules.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">cssRule</span>) </span>{
        <span class="hljs-built_in">console</span>.log(cssRule.cssText);
    });
}
</code></pre>
<h3 id="-">响应式网站布局</h3>
<p>使用媒体查询实现，可以多端共用一套页面，不过需要多端页面结构必须一致，对于移动端可能需要冗余一些请求。</p>
<h2 id="cookie-">Cookie操作</h2>
<pre><code class="lang-javascript"><span class="hljs-comment">// 取Cookies</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getCookie</span>(<span class="hljs-params">name</span>) </span>{
  <span class="hljs-keyword">var</span> value = <span class="hljs-built_in">document</span>.cookie.match(<span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">'(^| )'</span> + name + <span class="hljs-string">'=([^;]*)(;|$)'</span>));
  <span class="hljs-keyword">if</span>(value != <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-built_in">unescape</span>(value[<span class="hljs-number">2</span>]); <span class="hljs-comment">// unescape函数进行解码</span>

  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
}

<span class="hljs-comment">// 存Cookies</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setCookie</span>(<span class="hljs-params">name, value, date, domain, path</span>) </span>{ <span class="hljs-comment">// date为过期时间对象</span>
    <span class="hljs-keyword">var</span> arr = [];

    arr.push(name + <span class="hljs-string">'='</span> + <span class="hljs-built_in">escape</span>(value));
    <span class="hljs-keyword">if</span>(domain) arr.push(<span class="hljs-string">'domain='</span> + <span class="hljs-built_in">escape</span>(domain));
    <span class="hljs-keyword">if</span>(path) arr.push(<span class="hljs-string">'path='</span> + <span class="hljs-built_in">escape</span>(path));
    arr.push(<span class="hljs-string">'expires='</span> + <span class="hljs-built_in">date</span>.toGMTString());

  <span class="hljs-built_in">document</span>.cookie = arr.join(<span class="hljs-string">';'</span>);
}

<span class="hljs-comment">// 删Cookies</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">delCookie</span>(<span class="hljs-params">name, domain, path</span>) </span>{
  <span class="hljs-keyword">var</span> dateLine = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();
  dateLine.setDate(dateLine.getDate() - <span class="hljs-number">1</span>); <span class="hljs-comment">// 设置过期日期为已过去的时间</span>

  <span class="hljs-keyword">var</span> dvalue = getCookie(name);
  <span class="hljs-keyword">if</span>(dvalue != <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">var</span> arr = [];

    arr.push(name + <span class="hljs-string">'='</span> + <span class="hljs-built_in">escape</span>(dvalue));
    <span class="hljs-keyword">if</span>(domain) arr.push(<span class="hljs-string">'domain='</span> + <span class="hljs-built_in">escape</span>(domain));
    <span class="hljs-keyword">if</span>(path) arr.push(<span class="hljs-string">'path='</span> + <span class="hljs-built_in">escape</span>(path));
    arr.push(<span class="hljs-string">'expires='</span> + dateLine.toGMTString());

    <span class="hljs-built_in">document</span>.cookie = arr.join(<span class="hljs-string">';'</span>);
  }
}
</code></pre>
<h2 id="-">正则</h2>
<p>关于正则表达式，支持的方法有：</p>
<ul>
<li>字符串的<code>match</code>、<code>search</code>、<code>replace</code>和<code>split</code></li>
<li>正则表达式对象的<code>exec</code>和<code>test</code></li>
</ul>
<h3 id="-">声明正则</h3>
<pre><code class="lang-javascript"><span class="hljs-comment">// 方法一</span>
<span class="hljs-keyword">var</span> reg = <span class="hljs-regexp">/d(\w+)/ig</span>;

<span class="hljs-comment">// 方法二</span>
<span class="hljs-keyword">var</span> reg = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">'d(\\w+)'</span>, <span class="hljs-string">'ig'</span>);
</code></pre>
<h3 id="exec">exec</h3>
<p>当声明的正则带有g属性时，表示全局搜索，那么每次执行exec都会返回下一次匹配到的结果数组，没有则返回null。</p>
<pre><code class="lang-javascript">var reg = <span class="hljs-regexp">/b(d+)/ig</span>;
reg.exec(<span class="hljs-string">'abdcbddtbdddg'</span>); <span class="hljs-regexp">//</span> 返回[<span class="hljs-string">'bd'</span>, <span class="hljs-string">'d'</span>]
reg.exec(<span class="hljs-string">'abdcbddtbdddg'</span>); <span class="hljs-regexp">//</span> 返回[<span class="hljs-string">'bdd'</span>, <span class="hljs-string">'dd'</span>]
reg.exec(<span class="hljs-string">'abdcbddtbdddg'</span>); <span class="hljs-regexp">//</span> 返回[<span class="hljs-string">'bddd'</span>, <span class="hljs-string">'ddd'</span>]
reg.exec(<span class="hljs-string">'abdcbddtbdddg'</span>); <span class="hljs-regexp">//</span> 返回null

<span class="hljs-regexp">//</span> exec方法是根据reg.lastIndex来获取下一次匹配的起始位置
</code></pre>
<h3 id="match">match</h3>
<p>字符串方法，当声明的正则带有g属性时，返回匹配到的所有子串，否则返回匹配到的第一个子串。</p>
<pre><code class="lang-javascript">var reg = <span class="hljs-regexp">/b(d+)/ig</span>;
<span class="hljs-string">'abdcbddtbdddg'</span>.match(reg); <span class="hljs-regexp">//</span> 返回[<span class="hljs-string">'bd'</span>, <span class="hljs-string">'bdd'</span>, <span class="hljs-string">'bddd'</span>]
</code></pre>
<h3 id="replace">replace</h3>
<p>字符串方法，用于替换字符串的某些内容。</p>
<pre><code class="lang-javascript">var reg = <span class="hljs-regexp">/(\w+)\s(\w+)/ig</span>;
<span class="hljs-string">'aa bb'</span>.replace(reg, <span class="hljs-string">'$2 $1'</span>); <span class="hljs-regexp">//</span> 返回<span class="hljs-string">'bb aa'</span>
<span class="hljs-string">'aa bb'</span>.replace(reg, <span class="hljs-keyword">function</span>(all, <span class="hljs-variable">$1</span>, <span class="hljs-variable">$2</span>) {
    <span class="hljs-regexp">//</span> all表示整个串，<span class="hljs-variable">$1</span>表示第一个捕获，<span class="hljs-variable">$2</span>表示第二个捕获
    <span class="hljs-regexp">//</span> 返回<span class="hljs-string">'bb aa'</span>
    return <span class="hljs-variable">$2</span> + <span class="hljs-string">' '</span> + <span class="hljs-variable">$1</span>;
});
</code></pre>
<h2 id="-">垃圾回收</h2>
<h3 id="-">引用计数</h3>
<p>只要“对象有没有其他对象引用到它”，对象就被标记为不需要的，然后对该对象占用的内存进行回收。此种方法的局限在于当存在循环引用的情况下，即使对象是不需要的，也不会被清除。</p>
<p>IE6、IE7即采用此种方式进行垃圾回收。</p>
<h3 id="-">标记清除</h3>
<p>这个算法把“对象是否可以获得”作为标记对象是否为不需要的条件。这个算法假定设置一个叫做根的对象（在Javascript里，根是全局对象），垃圾回收器会定期地从根开始找所有从根开始引用的对象，然后找这些对象引用的对象。从根开始，垃圾回收器将找到所有可以获得的对象和所有不能获得的对象。所有不能获得的对象即为要清除的对象。</p>
<p>从2012年起，所有现代浏览器都使用了标记清除垃圾回收算法。</p>
<h2 id="-">其他</h2>
<h3 id="ajax">AJAX</h3>
<ul>
<li>优点：局部刷新，占用流量小。</li>
<li>缺点：请求是异步的。</li>
</ul>
<h4 id="-">创建请求对象</h4>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> xhr
<span class="hljs-keyword">if</span>(window.XMLHttpRequest){
    xhr= <span class="hljs-keyword">new</span> <span class="hljs-type">XMLHttpRequest</span>();
}<span class="hljs-keyword">else</span> {
    <span class="hljs-comment">// IE6以下</span>
    xhr= <span class="hljs-keyword">new</span> <span class="hljs-type">ActiveXObject</span>(“Microsoft.XMLHTTP”);
}
</code></pre>
<h4 id="-">添加回调</h4>
<pre><code class="lang-javascript">xhr.onreadystatechange = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">if</span>(xhr.readyState==<span class="hljs-number">4</span> &amp;&amp; xhr.status==<span class="hljs-number">200</span>) {
        <span class="hljs-comment">// 通过xhr.responseText或xhr.responseXML获取返回数据</span>
        <span class="hljs-comment">// 进行其他操作</span>
    }
};

<span class="hljs-comment">//readyState:0表示初始化，1表示连接，2表示接收，3表示处理，4表示完成；</span>
<span class="hljs-comment">//status:200表示OK，404表示未找到页面；</span>
</code></pre>
<h4 id="-">发送请求</h4>
<pre><code class="lang-javascript">
<span class="hljs-comment">//Get请求</span>
<span class="hljs-selector-tag">xhr</span><span class="hljs-selector-class">.open</span>(<span class="hljs-string">'GET'</span>, url, true); <span class="hljs-comment">//第二个参数是请求url，第三个参数是指是否采用异步</span>
<span class="hljs-selector-tag">xhr</span><span class="hljs-selector-class">.send</span>();

<span class="hljs-comment">//Post请求</span>
<span class="hljs-selector-tag">xhr</span><span class="hljs-selector-class">.open</span>(<span class="hljs-string">'POST'</span>, url, true); <span class="hljs-comment">//同上</span>
<span class="hljs-selector-tag">xhr</span><span class="hljs-selector-class">.setRequestHeader</span>(header, value); <span class="hljs-comment">//设置表头，一般我们提交的form是用xhr.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');</span>
<span class="hljs-selector-tag">xhr</span><span class="hljs-selector-class">.send</span>(<span class="hljs-string">'xxx=xxx&amp;aa=aaa'</span>);
</code></pre>
<h4 id="-">其他</h4>
<pre><code><span class="hljs-number">1</span>、创建XHR对象
new ActiveXObject('Microsoft.XMLHTTP')  <span class="hljs-string">| 适用于支持window.ActiveXObject的ie5和ie6等</span>
new XMLHttpRequest()                    <span class="hljs-string">| 适用于ie7+/ff/chrome/safari/opera等</span>

<span class="hljs-number">2</span>、XHR对象的属性和方法
readyState                   <span class="hljs-string">| 通信状态，取值0~4，见后文</span>
onreadystatechange           <span class="hljs-string">| readyState改变时触发此事件</span>
responseText                 <span class="hljs-string">| 服务器返回的文本格式文档</span>
responseXML                  <span class="hljs-string">| 服务器返回的XML格式文档</span>
status                       <span class="hljs-string">| 状态码，如100，200,404,500等</span>
statusText                   <span class="hljs-string">| 状态码对应的文本（OK/Not Found)</span>
abort()                      <span class="hljs-string">| 中止当前请求</span>
open(method,url)             <span class="hljs-string">| 打开一个请求</span>
send(args)                   <span class="hljs-string">| 发送请求</span>
setRequestHeader(key,value)  <span class="hljs-string">| 设置请求的头部</span>
getResponseHeader(key)       <span class="hljs-string">| 获取响应的头部值</span>
getAllResponseHeaders()      <span class="hljs-string">| 以键值对形式返回所有头部信息</span>

<span class="hljs-number">3</span>、readyState各个值含义
<span class="hljs-number">0</span>  <span class="hljs-string">| 代表一个未初始化的状态。以创建未初始化的XHR对象</span>
<span class="hljs-number">1</span>  <span class="hljs-string">| 代表连接状态。已经调用了open方法，准备发送请求</span>
<span class="hljs-number">2</span>  <span class="hljs-string">| 代表发送状态。已经调用了send方法，尚未得到响应数据</span>
<span class="hljs-number">3</span>  <span class="hljs-string">| 代表正在接收状态，已经接收了HTTP响应的头部信息，正在接收响应内容</span>
<span class="hljs-number">4</span>  <span class="hljs-string">| 代表已经加载状态，此时响应内容已经被完全接收</span>
</code></pre><h3 id="-">跨域请求</h3>
<p>当两个域协议不同、端口不同或域名不同则属于不同源，不同源页面之间的通信则称之为跨域。</p>
<h4 id="cors">CORS</h4>
<p>http提供的一个允许跨域请求的方法，只有高版本浏览器支持。主要通过设置请求头和相应头来实现，一般前端无需做什么特殊操作，浏览器会把相应的字段追加到请求上去，工作主要集中在服务器端。其中主要用到的头信息是<code>origin</code>和<code>Access-Control-Allow-Origin</code>。</p>
<p>具体流程可阅读阮大神的<a href="http://www.ruanyifeng.com/blog/2016/04/cors.html">文章</a>学习。</p>
<h4 id="jsonp">JSONP</h4>
<p>页面中的src属性是可以跨域获取资源的：</p>
<pre><code class="lang-html"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">scirpt</span>&gt;</span>
    window.dosth = function(data) </span><span class="hljs-template-variable">{
        // dosth为回调函数，名字可以自己定
    }</span><span class="xml">
<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span> = <span class="hljs-string">"http://aa.bb/c.action?callback=dosth"</span>&gt;</span><span class="undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span>
</code></pre>
<h4 id="iframe">iframe</h4>
<p>可已通过修改document.domain、window.name或postMessage来做。</p>
<p>PS：document.domain只可修改成和当前一样或更高级的父域。如a.c.b.com只可修改成a.c.b.com、c.b.com和b.com。
PS：window.name可以在同一个窗口内一直保存，所以在iframe中修改了window.name，然后将iframe的src改成同域的，父亲就可以通过iframe.contentWindow.name获取。</p>
<h3 id="-">文件上传</h3>
<h4 id="-">传统方式</h4>
<pre><code class="lang-html">&lt;<span class="hljs-keyword">form</span> action=<span class="hljs-string">"xxx.do"</span> method=<span class="hljs-string">"post"</span> enctype=<span class="hljs-string">"multipart/form-data"</span> &gt;
    &lt;<span class="hljs-keyword">input</span> <span class="hljs-keyword">type</span>=<span class="hljs-string">"file"</span> id=<span class="hljs-string">"yyy"</span> name=<span class="hljs-string">"yyy"</span>&gt;
    &lt;<span class="hljs-keyword">input</span> <span class="hljs-keyword">type</span>=<span class="hljs-string">"submit"</span> value=<span class="hljs-string">"上传"</span>&gt;
&lt;/<span class="hljs-keyword">form</span>&gt;
</code></pre>
<p>以上方式是同步提交，如过想要实现异步提交的话，可用iframe来做。</p>
<h4 id="html5">HTML5</h4>
<p>使用formData来构建一个虚拟表单，然后使用ajax提交。</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">if</span>(<span class="hljs-built_in">window</span>.FormData) {
    <span class="hljs-keyword">var</span> formData = <span class="hljs-keyword">new</span> FormData();
    <span class="hljs-comment">// 添加要上传的文件</span>
    formData.append(<span class="hljs-string">'upload'</span>, <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'yyy'</span>).files[<span class="hljs-number">0</span>]);

    <span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest();
    xhr.open(<span class="hljs-string">'POST'</span>, <span class="hljs-string">'xxx.do'</span>);
    xhr.onload = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">if</span>(xhr.status === <span class="hljs-number">200</span>) {
            <span class="hljs-comment">// success</span>
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-comment">// error</span>
        }
    };
    xhr.send(formData);

    <span class="hljs-comment">// 监听上传进度</span>
    xhr.upload.onprogress = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) </span>{
        <span class="hljs-keyword">if</span>(event.lengthComputable) {
            <span class="hljs-comment">// evnet.loaded - 已上传</span>
            <span class="hljs-comment">// event.total - 总共</span>
        }
    };
}
</code></pre>
<h3 id="-">长连接技术</h3>
<h4 id="eventsource">EventSource</h4>
<p>轮询接口，当其中一个轮询请求未回来会阻塞轮询，IE未实现。</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> polling = <span class="hljs-keyword">new</span> EventSource(<span class="hljs-built_in">url</span>, {
    <span class="hljs-attribute">withCredentials</span>: <span class="hljs-literal">true</span> <span class="hljs-comment">// 是否携带cookie，支持CORS模式</span>
});

polling.addEventListener(eventName, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) </span>{
    <span class="hljs-comment">// eventName表示轮询回来需要触发的事件名</span>
    <span class="hljs-comment">// event.data - 轮询回来的数据</span>
});
polling.onmessage = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{}; <span class="hljs-comment">// 无事件名的一律进入onmessage</span>
polling.onerror = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{}; <span class="hljs-comment">// 异常事件回调</span>
polling.onopen = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{}; <span class="hljs-comment">// 开始轮询回调</span>

polling.close(); <span class="hljs-comment">// 关闭轮询</span>
</code></pre>
<h4 id="websocket">webSocket</h4>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> websocket = <span class="hljs-keyword">new</span> WebSocket(<span class="hljs-built_in">url</span>);

websocket.onopen = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{}; <span class="hljs-comment">// 开始长连接回调</span>
websocket.onmessage = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) </span>{
    <span class="hljs-comment">// 收到消息回调</span>
    <span class="hljs-comment">// event.data - 收到的消息数据</span>
};

websocket.send(data); <span class="hljs-comment">// data可以为字符串、Blob或ArrayBuffer</span>
</code></pre>
<h3 id="-">音频/视频</h3>
<h4 id="-">音频</h4>
<p>HTML5提供了<code>&lt;audio&gt;</code>元素来支持音频。以MOozilla核心的Firefox浏览器只支持<code>.ogg</code>文件，webkit核心的浏览器支持<code>.mp3</code>扩展，safari不承认<code>.ogg</code>,它会跳过并移到<code>.mp3</code>版本。所以需要创建两个版本的音频。</p>
<p>Audio支持三种音频格式：Ogg Vorbis，MP3，Wav。</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">audio</span> <span class="hljs-attr">autoplay</span>=<span class="hljs-string">"autoplay"</span> <span class="hljs-attr">controls</span>=<span class="hljs-string">"controls"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"xxx.ogg"</span>/&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"xxx.mp3"</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">audio</span>&gt;</span>
<span class="hljs-comment">&lt;!--标签的属性与video相同。没有height与width。--&gt;</span>
</code></pre>
<h4 id="-">视频</h4>
<ul>
<li>Ogg：带有<code>Theora</code>视频编码和<code>Vorbis</code>音频编码的文件</li>
<li>MPEG4：带有<code>H.264</code>视频编码和<code>AAC</code>音频编码的MPEG4文件</li>
<li>WebM：<code>VP8</code>视频编码和<code>Vorbis</code>音频编码的文件</li>
</ul>
<p>HTML5的规范没有指定特定的视频编解码器，它留给了浏览器来决定。Safari和IE9预期支持<code>H.264</code>格式的视频，Firefox和Opera坚持开源的<code>Theora</code>和<code>Vorbis</code>格式，所以需要提供两种格式。</p>
<p>Video支持三种视频格式：Ogg，MPEG4，WebM。</p>
<pre><code class="lang-html"><span class="hljs-comment">&lt;!-- 此属性表示视频在页面加载时进行加载，预备播放。如果设置为"autoplay"，就忽略该属性。controls用于显示如播放按钮的控件--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">video</span> <span class="hljs-attr">controls</span>=<span class="hljs-string">"preload"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"xxx.ogv"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"video/ogg; codecs='vorbis,theora'"</span>/&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"xxx.mp4"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"vide0/mp4; codecs='avc1.42E01E,mp4a.40.2'"</span>/&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>你的浏览器太旧了。<span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"xxx.mp4"</span>&gt;</span>下载这个视频。<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">video</span>&gt;</span>
</code></pre>
<p>PS：技术上是不需要设置type属性的，但是不这样做的话，浏览器就会自己去寻找类型，为了节省一些带宽，最好还是声明下。
PS：不是所有的浏览器都支持HTML5，所以在资源元素的下面，可以提供一个下载链接或者嵌入视频的flash版本替代，这取决于个人。</p>
<h3 id="-">桌面提醒</h3>
<h4 id="-">申请权限</h4>
<pre><code class="lang-javascript">Notification.requestPermission(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(status)</span> </span>{
  <span class="hljs-comment">// 此接口用于向浏览器用户申请通知权限，申请方式为弹框申请</span>
  <span class="hljs-comment">// 其中status为granted为用户同意，denied为用户拒绝，default为用户没有做任何许可，因此也不会弹出通知</span>
});
</code></pre>
<h4 id="-">创建桌面提醒</h4>
<pre><code class="lang-javascript"><span class="hljs-built_in">var</span> n = <span class="hljs-literal">new</span> Notification(title, {
  dir: <span class="hljs-string">''</span>, <span class="hljs-comment">// 文字方向，auto，ltr(从左向右)，rtl(从右向左)</span>
  lang: <span class="hljs-string">''</span>, <span class="hljs-comment">// 语种</span>
  body: <span class="hljs-string">''</span>, <span class="hljs-comment">// 通知内容</span>
  <span class="hljs-built_in">tag</span>: <span class="hljs-string">''</span>, <span class="hljs-comment">// 通知的ID，格式为字符串。一组相同tag的通知，不会同时显示，只会在用户关闭前一个通知后，在原位置显示</span>
  icon: <span class="hljs-string">''</span>, <span class="hljs-comment">// 图标的url</span>
});

n.close();  <span class="hljs-comment">//关闭通知</span>
</code></pre>
<h4 id="-">支持的事件</h4>
<pre><code>click | 点击通知事件
show  | 显示通知事件
close | 关闭事件
<span class="hljs-keyword">error </span>| 通知显示出错事件
</code></pre><h3 id="-">地理位置</h3>
<pre><code class="lang-javascript"><span class="hljs-keyword">if</span>(navigator.geolocation) {
    navigator.geolocation.getCurrentPosition(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(position)</span> </span>{
        <span class="hljs-comment">// 成功</span>
        <span class="hljs-comment">// position对象有以下属性：</span>
        <span class="hljs-comment">// position.coords.latitude：十进制数的纬度</span>
        <span class="hljs-comment">// position.coords.longitude：十进制数的经度</span>
        <span class="hljs-comment">// position.coords.accuracy：位置精度</span>
        <span class="hljs-comment">// position.coords.altitude：海拔，海平面以上以米计</span>
        <span class="hljs-comment">// position.coords.altitudeAccuracy：位置的海拔精度</span>
        <span class="hljs-comment">// position.coords.heading：方向，从正北开始以度计</span>
        <span class="hljs-comment">// position.coords.speed：速度，以米/每秒计</span>
        <span class="hljs-comment">// position.timestamp：响应的日期/时间</span>
    }, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(error)</span> </span>{
        <span class="hljs-comment">// 失败</span>
        <span class="hljs-comment">// errer.code 可能为以下四种：</span>
        <span class="hljs-comment">// error.PERMISSION_DENIED：用户不允许地理定位</span>
        <span class="hljs-comment">// error.POSITION_UNAVAILABLE：无法获取当前地址</span>
        <span class="hljs-comment">// error.TIMEOUT：操作超时</span>
        <span class="hljs-comment">// error.UNKNOWN_ERROR：未知错误</span>
    });
} <span class="hljs-keyword">else</span> {
    alert(<span class="hljs-string">'不支持Geolocaltion'</span>);
}

<span class="hljs-comment">// 当需要观测位置信息，当位置信息变化触发回调时，可用以下接口</span>
<span class="hljs-keyword">var</span> id = navigator.geolocation.watchPosition(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{});
navigator.geolocation.clearWatch(id); <span class="hljs-comment">// 停止观测</span>
</code></pre>
<h3 id="-">文件系统</h3>
<p>fileReader对象提供了读取用户计算机上文件内容的接口。可使用的对象包括File对象、Blob对象、input元素的filelist或者拖放操作中的dataTransfer等。</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> fr = <span class="hljs-function"><span class="hljs-keyword">new</span> <span class="hljs-title">FileReader</span>();

/* 方法 */
<span class="hljs-title">fr</span>.<span class="hljs-title">abort</span>(); <span class="hljs-comment">// 中断读取</span>
<span class="hljs-title">fr</span>.<span class="hljs-title">readAsArrayBuffer</span>(file); <span class="hljs-comment">// 读取为ArrayBuffer</span>
<span class="hljs-title">fr</span>.<span class="hljs-title">readAsBinaryString</span>(file); <span class="hljs-comment">// 读取为二进制字符串</span>
<span class="hljs-title">fr</span>.<span class="hljs-title">readAsDataURL</span>(file); <span class="hljs-comment">// 读取为如data:URL格式的base64字符串</span>
<span class="hljs-title">fr</span>.<span class="hljs-title">readAsText</span>(file); <span class="hljs-comment">// 读取为纯文本</span>

/* 事件 */
<span class="hljs-title">fr</span>.<span class="hljs-title">onload</span> = <span class="hljs-title">function</span>() {
    <span class="hljs-comment">// 当读取操作成功完成时调用</span>
    <span class="hljs-comment">// fr.result - 读取到的结果</span>
};

<span class="hljs-title">fr</span>.<span class="hljs-title">onabort</span> <span class="hljs-comment">// 当读取操作被中止时调用</span>
<span class="hljs-title">fr</span>.<span class="hljs-title">onerror</span> <span class="hljs-comment">// 当读取操作发生错误时调用</span>
<span class="hljs-title">fr</span>.<span class="hljs-title">onloadend</span> <span class="hljs-comment">// 当读取操作完成时调用,不管是成功还是失败.该处理程序在onload或者onerror之后调用</span>
<span class="hljs-title">fr</span>.<span class="hljs-title">onloadstart</span> <span class="hljs-comment">// 当读取操作将要开始之前调用</span>
<span class="hljs-title">fr</span>.<span class="hljs-title">onprogress</span> <span class="hljs-comment">// 在读取数据过程中周期性调用</span></span>
</code></pre>
<h3 id="-">客户端数据库</h3>
<p>webSql已被弃用，推荐使用indexedDB.</p>
<h3 id="-">本地存储系统</h3>
<ul>
<li>localStorage：可以长期存储数据而没有时间限制。</li>
<li>SessionStorage：不能长期存储数据，数据会随着浏览器的关闭而删除。</li>
</ul>
<p>低版本IE下有一个userData对象实现了类似的接口。</p>
<p>用法：</p>
<pre><code>localStorage.setItem(<span class="hljs-string">'xxx'</span>, <span class="hljs-string">'xxx'</span>);
<span class="hljs-keyword">var</span> xxx = localStorage.getItem(<span class="hljs-string">'xxx'</span>);
localStorage.removeItem(<span class="hljs-string">'xxx'</span>);
localStorage.clear();
</code></pre><h3 id="-">离线应用缓存</h3>
<p>使用manifest文件：</p>
<pre><code class="lang-html">&lt;<span class="hljs-selector-tag">html</span> manifest = <span class="hljs-string">"XX.manifest"</span>&gt;
</code></pre>
<pre><code><span class="hljs-meta">#</span><span class="bash">xx.manifest内容如下</span>
CACHE MANIFEST
<span class="hljs-meta">#</span><span class="bash"> 在此标题下列出的文件将在首次下载后进行缓存</span>
<span class="hljs-meta">#</span><span class="bash"> 2016-03-18 v1.0.0</span>
/theme.css
/logo.gif
/main.js

NETWORK:
<span class="hljs-meta">#</span><span class="bash"> 在此标题下列出的文件需要与服务器的连接，且不会被缓存</span>
login.asp

FALLBACK:
<span class="hljs-meta">#</span><span class="bash"> 在此标题下列出的文件规定当页面无法访问时的回退页面（比如 404 页面）</span>
/404.html
</code></pre><p>特点：</p>
<ul>
<li>manifest有变化才更新，所以文件有变化要修改manifest文件（如修改manifest文件中的时间版本信息）。</li>
<li>一次更新manifest中的所有文件（有一个文件更新失败则全部回撤）。</li>
<li>此次更新下次才生效。</li>
</ul>
<h3 id="-">历史记录管理</h3>
<p>window.history对象是浏览器提供的一个用于操纵历史记录的接口。</p>
<pre><code class="lang-javascript">history.forward(); <span class="hljs-comment">// 相当于历史记录中的前进</span>
history.back(); <span class="hljs-comment">// 相当于历史记录中的后退</span>
history.go(<span class="hljs-number">-2</span>); <span class="hljs-comment">// 相当与历史记录中的后退两次</span>
history.length; <span class="hljs-comment">// 历史记录栈中有多少条记录</span>

<span class="hljs-comment">/* html5中添加 */</span>
history.pushState(stateObj, title, <span class="hljs-built_in">url</span>); <span class="hljs-comment">// 添加历史记录，常用于单页系统中</span>
history.replaceState(stateObj, title, <span class="hljs-built_in">url</span>); <span class="hljs-comment">// 替换历史记录，常用于无刷新修改url</span>
<span class="hljs-built_in">window</span>.onpopstate = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{}; <span class="hljs-comment">// 历史记录变化时触发的事件</span>
</code></pre>
<h3 id="-">拖拽</h3>
<h4 id="drop-drag">drop和drag</h4>
<p>HTML5提供了drop和drag来实现拖拽。可供拖拽的只有图片、超链接等部分元素。对于需要被拖拽的元素，要将元素的draggable属性设置为true，然后通过监听事件进行操作。</p>
<pre><code>dragstart：当一个元素开始被拖拽的时候触发。用户拖拽的元素需要附加dragstart事件。在这个事件中，监听器将设置与这次拖拽相关的信息，例如拖动的数据和图像。

dragenter：当拖拽中的鼠标第一次进入一个元素的时候触发。这个事件的监听器需要指明是否允许在这个区域释放鼠标。如果没有设置监听器，或者监听器没有进行操作，则默认不允许释放。当你想要通过类似高亮或插入标记等方式来告知用户此处可以释放，你将需要监听这个事件。

dragover：当拖拽中的鼠标移动经过一个元素的时候触发。大多数时候，监听过程发生的操作与dragenter事件是一样的。

dragleave：当拖拽中的鼠标离开元素时触发。监听器需要将作为可释放反馈的高亮或插入标记去除。

drag：这个事件在拖拽源触发。即在拖拽操作中触发dragstart事件的元素。

<span class="hljs-built_in">drop</span>：这个事件在拖拽操作结束释放时于释放元素上触发。一个监听器用来响应接收被拖拽的数据并插入到释放之地。这个事件只有在需要时才触发。当用户取消了拖拽操作时将不触发，例如按下了Escape（ESC）按键，或鼠标在非可释放目标上释放了按键。

dragend：拖拽源在拖拽操作结束将得到dragend事件对象，不管操作成功与否。
</code></pre><p>与事件相关的数据均存放到event.dataTransfer中，通过调用相关的API完成数据操作。</p>
<h4 id="-js-">原生js实现</h4>
<p>通过mousedown、mousemove和mouseup事件来实现，移动的位置通过获取鼠标的坐标来计算。下面是一个简单的例子：</p>
<pre><code class="lang-html"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"utf-8"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/css"</span>&gt;</span><span class="css">
    <span class="hljs-selector-id">#haha</span>{
        <span class="hljs-attribute">position</span>:absolute;
        <span class="hljs-attribute">margin</span>:-<span class="hljs-number">100px</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> -<span class="hljs-number">100px</span>;
        <span class="hljs-attribute">background</span>:<span class="hljs-number">#0C9</span>;
        <span class="hljs-attribute">width</span>:<span class="hljs-number">200px</span>;
        <span class="hljs-attribute">height</span>:<span class="hljs-number">200px</span>;
    }
    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"haha"</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"left:0;top:0;"</span> <span class="hljs-attr">onMouseDown</span>=<span class="hljs-string">mouseDown()</span> <span class="hljs-attr">onMouseUp</span>=<span class="hljs-string">mouseUp()</span> <span class="hljs-attr">onMouseMove</span>=<span class="hljs-string">mouseMove()</span> <span class="hljs-attr">onMouseOut</span>=<span class="hljs-string">mouseOut()</span> <span class="hljs-attr">onMouseOver</span>=<span class="hljs-string">mouseOver()</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span>&gt;</span><span class="javascript">
    <span class="hljs-built_in">window</span>.onload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-comment">// 将div设置在屏幕中间</span>
        <span class="hljs-keyword">var</span> div = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'haha'</span>);
        div.style.left = <span class="hljs-built_in">document</span>.documentElement.clientWidth/<span class="hljs-number">2</span> + <span class="hljs-string">'px'</span>;
        div.style.top = <span class="hljs-built_in">document</span>.documentElement.clientHeight/<span class="hljs-number">2</span> + <span class="hljs-string">'px'</span>;
    }

    <span class="hljs-keyword">var</span> position = {
        <span class="hljs-string">'isMouseDown'</span>: <span class="hljs-number">0</span>, <span class="hljs-comment">// 鼠标是否被按下，0表示未被按下，1表示被按下</span>
        <span class="hljs-string">'ox'</span>: <span class="hljs-number">0</span>, <span class="hljs-comment">// 鼠标按下位置和div左上角的横向位移偏移</span>
        <span class="hljs-string">'oy'</span>: <span class="hljs-number">0</span>, <span class="hljs-comment">// 鼠标按下位置和div左上角的纵向位移偏移</span>
    }
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mouseDown</span>(<span class="hljs-params">e</span>) </span>{ <span class="hljs-comment">// 按下鼠标时</span>
        <span class="hljs-keyword">var</span> e = e || event;
        <span class="hljs-keyword">var</span> div = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'haha'</span>);
        position.isMouseDown = <span class="hljs-number">1</span>; <span class="hljs-comment">// 将鼠标状态置为按下</span>
        <span class="hljs-comment">//记录偏移位置</span>
        position.ox = e.clientX - <span class="hljs-built_in">parseInt</span>(div.style.left);
        position.oy = e.clientY - <span class="hljs-built_in">parseInt</span>(div.style.top);
    }
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mouseMove</span>(<span class="hljs-params">e</span>) </span>{ <span class="hljs-comment">// 移动鼠标时</span>
        <span class="hljs-keyword">var</span> e = e || event;
        <span class="hljs-keyword">var</span> div = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'haha'</span>);

        <span class="hljs-keyword">if</span>(position.isMouseDown==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;

        div.style.left = e.clientX - position.ox + <span class="hljs-string">'px'</span>;
        div.style.top = e.clientY - position.oy + <span class="hljs-string">'px'</span>;
    }
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mouseUp</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-comment">// 鼠标移开时，将鼠标状态和偏移状态重置</span>
        position.isMouseDown = <span class="hljs-number">0</span>;
        position.ox = <span class="hljs-number">0</span>;
        position.oy = <span class="hljs-number">0</span>;
    }
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mouseOver</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-comment">// 鼠标移上去后的鼠标变化</span>
        vardiv = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'haha'</span>);
        div.style.cursor = <span class="hljs-string">'move'</span>;
    }
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mouseOut</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-comment">// 鼠标移开后的鼠标变化</span>
        vardiv = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'haha'</span>);
        div.style.cursor = <span class="hljs-string">'default'</span>;
        mouseUp();
    }
    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</code></pre>
<h3 id="-api">性能相关API</h3>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> timing = Performance.timing; <span class="hljs-comment">// 只读，是一个PerformanceTiming对象，包含了页面加载时间相关的性能信息。</span>
<span class="hljs-keyword">var</span> navinfo = Performance.navigation; <span class="hljs-comment">// 只读，是一个PerformanceNavigation对象，代表了页面浏览上下文的导航信息，比如大量获取资源的重定向。</span>

Performance.now(); <span class="hljs-comment">// 返回一个 DOMHighResTimeStamp 类实例表示距离页面开始请求到现在相差的毫秒数（即 Date.now() - Performance.timing.navigationStart ）。</span>
</code></pre>
<h3 id="canvas">Canvas</h3>
<p>画布相关，允许我们在页面上绘制图形。画布的坐标已画布左上角为起始点，以像素为单位计算。</p>
<pre><code class="lang-html">&lt;canvas <span class="hljs-attribute">id</span>=<span class="hljs-string">"canvas"</span> <span class="hljs-attribute">width</span>=<span class="hljs-string">"800"</span> <span class="hljs-attribute">height</span>=<span class="hljs-string">"800"</span>&gt;这里会显示当不支持canvas时的文字&lt;/canvas&gt;
</code></pre>
<p>ps: width和height最好在此处指明。</p>
<pre><code class="lang-javascript">var ctx = canvas.getContext(<span class="hljs-string">'2d'</span>); <span class="hljs-comment">// 获取画布上下文</span>

<span class="hljs-comment">/* 绘制矩形 */</span>
ctx.fillRect(x, y, <span class="hljs-built_in">width</span>, <span class="hljs-built_in">height</span>); <span class="hljs-comment">// 绘制一个填充的矩形</span>
ctx.strokeRect(x, y, <span class="hljs-built_in">width</span>, <span class="hljs-built_in">height</span>); <span class="hljs-comment">// 绘制一个矩形的边框</span>
ctx.clearRect(x, y, <span class="hljs-built_in">width</span>, <span class="hljs-built_in">height</span>); <span class="hljs-comment">// 清除指定矩形区域，让清除部分完全透明。</span>
ctx.<span class="hljs-built_in">rect</span>(x, y, <span class="hljs-built_in">width</span>, <span class="hljs-built_in">height</span>); <span class="hljs-comment">// 绘制一个左上角坐标为（x,y），宽高为width以及height的矩形到当前路径中。当该方法执行的时候，moveTo()方法自动设置坐标参数（0,0）。也就是说，当前笔触自动重置会默认坐标。</span>

<span class="hljs-comment">/* 绘制填充直线图形 */</span>
ctx.beginPath(); <span class="hljs-comment">// 开始路径</span>
ctx.moveTo(x, y); <span class="hljs-comment">// 移动</span>
ctx.lineTo(x1, y1); <span class="hljs-comment">// 画线</span>
ctx.lineTo(x2, y2);
ctx.<span class="hljs-built_in">fill</span>(); <span class="hljs-comment">// 填充封闭图形,所有没有闭合的形状都会自动闭合</span>

<span class="hljs-comment">/* 绘制非填充直线图形 */</span>
ctx.beginPath();
ctx.moveTo(x, y);
ctx.lineTo(x1, y1);
ctx.lineTo(x2, y2);
ctx.closePath(); <span class="hljs-comment">// 闭合路径，会把结束点和开始点连接上</span>
ctx.<span class="hljs-built_in">stroke</span>(); <span class="hljs-comment">// 描线</span>

<span class="hljs-comment">/* 绘制圆弧 */</span>
ctx.<span class="hljs-built_in">arc</span>(x, y, radius, startAngle, endAngle, anticlockwise); <span class="hljs-comment">// 画一个以（x,y）为圆心的以radius为半径的圆弧（圆），从startAngle开始到endAngle结束，按照anticlockwise给定的方向（默认为顺时针，即值为true）来生成。注意此处的angle不是角度而是弧度，一个圆的弧度是2*Math.PI</span>
ctx.arcTo(x1, y1, x2, y2, radius); <span class="hljs-comment">// 根据给定的控制点和半径画一段圆弧，再以直线连接两个控制点。</span>

<span class="hljs-comment">/* 绘制贝塞尔曲线 */</span>
ctx.quadraticCurveTo(cp1x, cp1y, x, y); <span class="hljs-comment">// 绘制二次贝塞尔曲线，x,y为结束点，cp1x,cp1y为控制点。</span>
ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y); <span class="hljs-comment">// 绘制三次贝塞尔曲线，x,y为结束点，cp1x,cp1y为控制点一，cp2x,cp2y为控制点二。</span>

<span class="hljs-comment">/* 使用Path2D对象来缓存或记录绘画命令 */</span>
var circle = Path2D(); <span class="hljs-comment">// 会返回一个新初始化的Path2D对象（可能将某一个路径作为变量——创建一个它的副本，或者将一个包含SVG path数据的字符串作为变量）</span>
circle.moveTo(<span class="hljs-number">125</span>, <span class="hljs-number">35</span>);
circle.<span class="hljs-built_in">arc</span>(<span class="hljs-number">100</span>, <span class="hljs-number">35</span>, <span class="hljs-number">25</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span> * Math.<span class="hljs-literal">PI</span>);

ctx.<span class="hljs-built_in">fill</span>(circle);

<span class="hljs-comment">/* 颜色 */</span>
ctx.fillStyle = <span class="hljs-built_in">color</span>; <span class="hljs-comment">// 设置图形的填充颜色。</span>
ctx.strokeStyle = <span class="hljs-built_in">color</span>; <span class="hljs-comment">// 设置图形轮廓的颜色。</span>

<span class="hljs-comment">/* 透明度 */</span>
ctx.globalAlpha = <span class="hljs-number">0.2</span>;

<span class="hljs-comment">/* 线条样式 */</span>
ctx.lineWidth = value; <span class="hljs-comment">// 设置线条宽度，默认为1.0。</span>
ctx.lineCap = type; <span class="hljs-comment">// 设置线条末端样式，值可为butt，round 和 square，默认是butt。</span>
ctx.lineJoin = type; <span class="hljs-comment">// 设定线条与线条间接合处的样式，值为round, bevel 和 miter，默认是miter。</span>
ctx.miterLimit = value; <span class="hljs-comment">// 限制当两条线相交时交接处最大长度；所谓交接处长度（斜接长度）是指线条交接处内角顶点到外角顶点的长度。</span>
ctx.getLineDash(); <span class="hljs-comment">// 返回一个包含当前虚线样式，长度为非负偶数的数组。</span>
ctx.setLineDash(segments); <span class="hljs-comment">// 设置当前虚线样式。</span>
ctx.lineDashOffset = value; <span class="hljs-comment">// 设置虚线样式的起始偏移量。</span>

<span class="hljs-comment">/* 渐变 */</span>
var linear = ctx.createLinearGradient(x1, y1, x2, y2); <span class="hljs-comment">// createLinearGradient 方法接受 4 个参数，表示渐变的起点 (x1,y1) 与终点 (x2,y2)。</span>
var radial = ctx.createRadialGradient(x1, y1, r1, x2, y2, r2); <span class="hljs-comment">// createRadialGradient 方法接受 6 个参数，前三个定义一个以 (x1,y1) 为原点，半径为 r1 的圆，后三个参数则定义另一个以 (x2,y2) 为原点，半径为 r2 的圆。</span>
linear.addColorStop(position, <span class="hljs-built_in">color</span>); <span class="hljs-comment">// addColorStop 方法接受 2 个参数，position 参数必须是一个 0.0 与 1.0 之间的数值，表示渐变中颜色所在的相对位置。例如，0.5 表示颜色会出现在正中间。color 参数必须是一个有效的 CSS 颜色值（如 #FFF， rgba(0,0,0,1)，等等）。</span>

<span class="hljs-comment">/* 图案 */</span>
var ptrn = ctx.createPattern(<span class="hljs-built_in">image</span>, type); <span class="hljs-comment">// 该方法接受两个参数。Image 可以是一个 Image 对象的引用，或者另一个 canvas 对象。Type 必须是下面的字符串值之一：repeat，repeat-x，repeat-y 和 no-repeat。</span>
ctx.fillStyle = ptrn; <span class="hljs-comment">// 以该图案为背景填充</span>
ctx.fillRect(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">150</span>, <span class="hljs-number">150</span>);

<span class="hljs-comment">/* 阴影 */</span>
ctx.shadowOffsetX = <span class="hljs-built_in">float</span>; <span class="hljs-comment">// shadowOffsetX 和 shadowOffsetY 用来设定阴影在 X 和 Y 轴的延伸距离，它们是不受变换矩阵所影响的。负值表示阴影会往上或左延伸，正值则表示会往下或右延伸，它们默认都为 0。</span>
ctx.shadowOffsetY = <span class="hljs-built_in">float</span>; <span class="hljs-comment">// shadowOffsetX 和 shadowOffsetY 用来设定阴影在 X 和 Y 轴的延伸距离，它们是不受变换矩阵所影响的。负值表示阴影会往上或左延伸，正值则表示会往下或右延伸，它们默认都为 0。</span>
ctx.shadowBlur = <span class="hljs-built_in">float</span>; <span class="hljs-comment">// shadowBlur 用于设定阴影的模糊程度，其数值并不跟像素数量挂钩，也不受变换矩阵的影响，默认为 0。</span>
ctx.shadowColor = <span class="hljs-built_in">color</span>; <span class="hljs-comment">// shadowColor 是标准的 CSS 颜色值，用于设定阴影颜色效果，默认是全透明的黑色。</span>

<span class="hljs-comment">/* 绘制文本 */</span>
ctx.fillText(<span class="hljs-built_in">text</span>, x, y [, maxWidth]); <span class="hljs-comment">// 在指定的(x,y)位置填充指定的文本，绘制的最大宽度是可选的。</span>
ctx.strokeText(<span class="hljs-built_in">text</span>, x, y [, maxWidth]); <span class="hljs-comment">// 在指定的(x,y)位置绘制文本边框，绘制的最大宽度是可选的。</span>
ctx.font = value; <span class="hljs-comment">// 当前我们用来绘制文本的样式. 这个字符串使用和 CSS font 属性相同的语法. 默认的字体是 10px sans-serif。</span>
ctx.<span class="hljs-built_in">textAlign</span> = value; <span class="hljs-comment">// 文本对齐选项. 可选的值包括：start, end, left, right or center. 默认值是 start。</span>
ctx.textBaseline = value; <span class="hljs-comment">// 基线对齐选项. 可选的值包括：top, hanging, middle, alphabetic, ideographic, bottom。默认值是 alphabetic。</span>
ctx.direction = value; <span class="hljs-comment">// 文本方向。可能的值包括：ltr, rtl, inherit。默认值是 inherit。</span>
ctx.measureText(<span class="hljs-string">'text'</span>); <span class="hljs-comment">// 将返回一个 TextMetrics对象的宽度、所在像素，这些体现文本特性的属性。</span>

<span class="hljs-comment">/* 绘制图片 */</span>
ctx.drawImage(<span class="hljs-built_in">image</span>, x, y[, <span class="hljs-built_in">width</span>, <span class="hljs-built_in">height</span>]); <span class="hljs-comment">// 其中 image 是 image 或者 canvas 对象，x 和 y 是其在目标 canvas 里的起始坐标。可传width和height来指明缩放大小。</span>
ctx.drawImage(<span class="hljs-built_in">image</span>, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight); <span class="hljs-comment">// 用于切片绘制，第一个参数和其它的是相同的，都是一个图像或者另一个 canvas 的引用。其它8个参数中，前4个是定义图像源的切片位置和大小，后4个则是定义切片的目标显示位置和大小。</span>
</code></pre>
<p>当然，canvas的api可不止有这么点，具体可参考<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API">mdn上的教程</a>。</p>
<h3 id="web-messaging">Web Messaging</h3>
<p>postMessage/onMessage通常用于当前窗口与iframe、frame或window.open打开的窗口之间的通信，可跨域。</p>
<pre><code class="lang-javascript">otherWindow.postMessage(message, origin); <span class="hljs-comment">// 发信息，origin为指定的域，不指定或值为'*'表示不限定otherWindow的域</span>

otherWindow.onmessage = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(event)</span> </span>{
    <span class="hljs-comment">// event.data - 发过来的message</span>
    <span class="hljs-comment">// event.origin - 消息来源的域</span>
    <span class="hljs-comment">// event.source - 消息来源的window引用</span>
};
</code></pre>
<h3 id="web-worker">Web Worker</h3>
<p>Worker 接口会生成真正的操作系统级别的线程，并让脚本文件运行在该线程中。简单来说，就是实现了前端的多线程。</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> myWorker = <span class="hljs-keyword">new</span> Worker(<span class="hljs-string">'task.js'</span>); <span class="hljs-comment">// 脚本文件必须是同源内的文件</span>

myWorker.onmessage = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(event)</span> </span>{
  <span class="hljs-comment">// event.data - 接收到的数据</span>
};

myWorker.postMessage(<span class="hljs-string">''</span>); <span class="hljs-comment">// 发送数据</span>

myWorker.terminate(); <span class="hljs-comment">// 终止worker</span>
</code></pre>
<p>task.js里的内容：</p>
<pre><code class="lang-javascript">postMessage(<span class="hljs-string">'aaa'</span>); <span class="hljs-comment">// 发送数据</span>

onmessage = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(event)</span> </span>{
  <span class="hljs-comment">// event.data - 接收到的数据</span>
};
</code></pre>
<h3 id="-">全屏接口</h3>
<pre><code class="lang-javascript"><span class="hljs-comment">// 进入全屏</span>
<span class="hljs-keyword">var</span> <span class="hljs-function"><span class="hljs-keyword">func</span> = <span class="hljs-title">elem</span>.<span class="hljs-title">requestFullscreen</span> || <span class="hljs-title">elem</span>.<span class="hljs-title">mozRequestFullScreen</span> || <span class="hljs-title">elem</span>.<span class="hljs-title">webkitRequestFullscreen</span>;
<span class="hljs-title">if</span><span class="hljs-params">(<span class="hljs-keyword">func</span>)</span></span> <span class="hljs-function"><span class="hljs-keyword">func</span>.<span class="hljs-title">call</span><span class="hljs-params">(elem)</span></span>;

<span class="hljs-comment">// 退出全屏</span>
<span class="hljs-keyword">var</span> <span class="hljs-function"><span class="hljs-keyword">func</span> = <span class="hljs-title">document</span>.<span class="hljs-title">cancelFullScreen</span> || <span class="hljs-title">document</span>.<span class="hljs-title">mozCancelFullScreen</span> || <span class="hljs-title">document</span>.<span class="hljs-title">webkitCancelFullScreen</span>;
<span class="hljs-title">if</span><span class="hljs-params">(<span class="hljs-keyword">func</span>)</span></span> <span class="hljs-function"><span class="hljs-keyword">func</span>.<span class="hljs-title">call</span><span class="hljs-params">(document)</span></span>;

<span class="hljs-comment">// 获取状态</span>
<span class="hljs-keyword">var</span> elem = document.fullscreenElement || document.mozFullScreenElement || document.webkitFullscreenElement; <span class="hljs-comment">// 正处于全屏状态的元素</span>
<span class="hljs-keyword">var</span> canFullScreen = document.fullscreenEnabled || document.mozFullscreenEnabled || document.webkitFullscreenEnabled; <span class="hljs-comment">// 能否进入全屏状态</span>
</code></pre>
<h3 id="page-visibility">Page Visibility</h3>
<pre><code class="lang-javascript"><span class="hljs-built_in">document</span>.hidden; <span class="hljs-comment">// 值为true或false，表示当前页面是否被激活</span>

<span class="hljs-comment">// hidden：当浏览器最小化、切换tab、电脑锁屏时visibilityState值是hidden</span>
<span class="hljs-comment">// visible：当document至少显示在一个屏幕（screen）当中时，返回visible；当浏览器窗口没有最小化，但是浏览器被其他应用遮挡时，visibilityState值也是visible</span>
<span class="hljs-comment">// prerender：文档加载离屏或者不可见时返回prerender，浏览器可选择性的支持这个属性</span>
<span class="hljs-comment">// unloaded：当document将要被unload时返回unloaded，浏览器可选择性的支持这个属性</span>
<span class="hljs-built_in">document</span>.visibilityState; <span class="hljs-comment">// 值可为以上四个，不过多数浏览器并未支持完全</span>

<span class="hljs-comment">// document上会添加visibilitychange事件，ducument可见性改变时触发</span>
</code></pre>
<h3 id="js-">js延迟加载</h3>
<h4 id="defer-ie-">defer（只支持IE）</h4>
<p>defer规定对脚本的加载进行延迟，直到页面加载完。故脚本不改变文档的内容的话，可用此方法。</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span> <span class="hljs-attr">defer</span>=<span class="hljs-string">"defer"</span>&gt;</span><span class="undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</code></pre>
<h4 id="async-html5-">async（HTML5属性）</h4>
<p>async规定一旦脚本可用，则异步执行。（仅能用于外部脚本）</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"XX.js"</span> <span class="hljs-attr">async</span>=<span class="hljs-string">"async"</span>&gt;</span><span class="undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</code></pre>
<h4 id="-">动态追加脚本</h4>
<p>创建script标签，插入到Dom中，加载完毕后callback</p>
<pre><code class="lang-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">loadScript</span>(<span class="hljs-params">url, callback</span>) </span>{
    <span class="hljs-keyword">var</span> script = <span class="hljs-built_in">document</span>.creatElement(<span class="hljs-string">'script'</span>);  <span class="hljs-comment">//创建script节点</span>
    script.type = <span class="hljs-string">'text/javascript'</span>;

    <span class="hljs-keyword">if</span>(script.readyState) {
        <span class="hljs-comment">// IE</span>
        script.onreadystatechange = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">if</span>(script.readyState == <span class="hljs-string">'loaded'</span> || script.readyState == <span class="hljs-string">'complete'</span>) {
                script.onreadystatechange = <span class="hljs-literal">null</span>;
                callback(); <span class="hljs-comment">// 回调</span>
            }
        };
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// 其他浏览器</span>
        script.onload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
            callback(); <span class="hljs-comment">// 回调</span>
        }
    }

    script.src = url;
    <span class="hljs-built_in">document</span>.body.appendChild(script); <span class="hljs-comment">// 添加到Dom中</span>
}
</code></pre>
<h2 id="-">性能优化</h2>
<ul>
<li>减少HTTP请求</li>
<li>使用CDN</li>
<li>禁止src/href指定空值</li>
<li>HTTP caching</li>
<li>gzip资源</li>
<li>CSS sprites</li>
<li>样式置顶/脚本置底</li>
<li>禁用CSS表达式（expression）</li>
<li>外联脚本/样式</li>
<li>分解资源载入（并行）/减少DNS查找</li>
<li>精简脚本/样式</li>
<li>禁止重定向</li>
<li>删除重复脚本/样式</li>
<li>使用GET方式的Ajax请求</li>
<li>减少DOM节点数量</li>
<li>减少Cookie大小</li>
<li>Cookie-Free域加载资源</li>
<li>减少DOM操作</li>
<li>优化图片/不要拉伸图片</li>
<li>禁用滤镜</li>
<li>用link替换@import载入样式</li>
<li>优化事件监听</li>
<li>减少IFrame数量</li>
</ul>
          
    </div>
</div>
</body>
</html>